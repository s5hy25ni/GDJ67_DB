-- 계층형과 셀프 조인

-- EMPNO 사원번호, MGR 사원번호(매니저)
SELECT e.EMPNO 사원번호, e.ENAME 사원이름, e2.ENAME 매니저이름
	FROM EMP e  LEFT JOIN EMP e2 
	ON e.EMPNO = e2.MGR  ;
	
CREATE TABLE EMPLOYEE(
	EMP VARCHAR2(1),
	MGR VARCHAR2(1)
);

INSERT INTO EMPLOYEE e VALUES('A', NULL); -- LEVER 1
INSERT INTO EMPLOYEE e VALUES('B', 'A'); -- LEAF NODE, LEVER 2
INSERT INTO EMPLOYEE e VALUES('C', 'A'); -- LEVER 2
INSERT INTO EMPLOYEE e VALUES('D', 'C'); -- LEAF NODE, LEVER 3
INSERT INTO EMPLOYEE e VALUES('E', 'C'); -- LEAF NODE, LEVER 3

SELECT *
	FROM EMPLOYEE e 
	
-- 순차진행
-- LEVEL 옵션은 반드시 진행방향인 CONNECT BY절이 있어야 함
SELECT LEVEL
	FROM DUAL
	CONNECT BY LEVEL <= 12;
	
SELECT TO_CHAR( HIREDATE , 'MM'), COUNT(*)
	FROM EMP e
	GROUP BY TO_CHAR( HIREDATE , 'MM')
	ORDER BY 1;
	
SELECT M 월, NVL(CNT, 0) "입사인원(명)"
	FROM (SELECT LEVEL M
				FROM DUAL
				CONNECT BY LEVEL <= 12)
	LEFT JOIN (SELECT TO_CHAR( HIREDATE , 'MM') M, COUNT(*) CNT
				FROM EMP e
				GROUP BY TO_CHAR( HIREDATE , 'MM')
				ORDER BY 1)
	USING(M)
	ORDER BY 1;
	
-- 순차진행
SELECT e.*, LEVEL
	FROM EMPLOYEE e 
	CONNECT BY PRIOR EMP=MGR 
	ORDER BY 1; -- 자기자신 + 위에 있는 애들
	
-- START WITH 는 CONNECT BY PRIOR 와 같이 써야 함, 순서는 상관 없음
SELECT *
	FROM EMPLOYEE e 
	CONNECT BY PRIOR EMP=MGR 
	START WITH MGR IS NULL
	ORDER BY 1;
	
-- LEVEL
SELECT e.*, LEVEL "LEVEL" -- 속해 있는 LEVEL 층
	, CONNECT_BY_ISLEAF LEAF -- 현재 ROW가 자식이 없으면(마지막 노드) 1, 있으면 0
	, LPAD(' ', (LEVEL-1)*10) || EMP "EMP"
	FROM EMPLOYEE e 
	CONNECT BY PRIOR EMP=MGR 
	START WITH MGR IS NULL
--	WHERE CONNECT_BY_ISLEAF=1 -- 안됨
	ORDER BY 1;

SELECT e.*, LEVEL "LEVEL"
	, CONNECT_BY_ISLEAF LEAF
	, LPAD(' ', (LEVEL-1)*10) || EMP "EMP"
	FROM EMPLOYEE e 
	CONNECT BY EMP= PRIOR MGR  -- MGR 시작 커럼 = PRIOR 검색 값
	START WITH MGR IS NULL
	ORDER BY 1;
	
-- 역차 전개 D -> C -> A
SELECT LEVEL, CONNECT_BY_ISLEAF, LPAD(' ', (LEVEL-1)*10) || EMP EMP
	FROM EMPLOYEE e 
	START WITH EMP='D'
	CONNECT BY EMP = PRIOR MGR;
-- WHERE 절 못옴
	
-- LEVEL : 구조의 DEPTH(층)을 나타냄(1부터)
-- CONNECT_BY_ISLEAF : 자식 노드가 있다면 0, 없다면 1
-- CONNECT_BY_ROOT (표현컬럼) : 현재에서 최상위 ROOT를 찾아 줌
-- SYS_CONNECT_BY_PATH(표현컬럼, 구분자) : 자신이 위치부터 추적하여 전개를 표현해줌 ex) D/C/A

-- START WITH : 선택한 ROW의 컬럼
-- CONNECT BY : 전개 방식
-- PRIOR : 시작 위치

-- START WITH MGR ~~ CONNECT BY MGR = PRIOR EMP

SELECT EMP, LEVEL 층, 
	CASE	CONNECT_BY_ISLEAF WHEN 1 THEN '마지막' ELSE '자식 있음' END 마지막확인,
	CONNECT_BY_ROOT EMP 최상위부모,
	SYS_CONNECT_BY_PATH(EMP, '>')  전개
	FROM EMPLOYEE e 
	START WITH MGR IS NULL
	CONNECT BY MGR = PRIOR EMP;
	
-- EMP 테이블을 도식화 시킨 후
-- 순차 정보를 출력 : LEVEL, 마지막확인, 최상위부모, 전개
SELECT ENAME, LEVEL 층,
	CASE CONNECT_BY_ISLEAF WHEN 0 THEN 'TRUE' ELSE 'FALSE' END 자식유무,
	CONNECT_BY_ROOT ENAME 최상위부모,
	SYS_CONNECT_BY_PATH(ENAME, '>') 
	FROM EMP e 
	START WITH MGR IS NULL
	CONNECT BY MGR = PRIOR EMPNO;

-- 7934의 역차 정보 출력 : 위 동일
SELECT ENAME, MGR, LEVEL 층,
	CASE CONNECT_BY_ISLEAF WHEN 0 THEN 'TRUE' ELSE 'FALSE' END 부모유무,
	CONNECT_BY_ROOT ENAME 마지막자식,
	SYS_CONNECT_BY_PATH(ENAME, '<') 
	FROM EMP e
	START WITH EMPNO = '7934'
	CONNECT BY EMPNO = PRIOR MGR;	
	
-- 가장 상위 관리자부터 하위 사원까지 상위 10개 레코드만 출력
SELECT ROWNUM, LV.*
	FROM (SELECT LPAD(' ', (LEVEL-1)*10) || JOB JOB, EMPNO, ENAME, MGR
				FROM EMP e
				START WITH MGR IS NULL
				CONNECT BY MGR = PRIOR EMPNO
				ORDER SIBLINGS BY EMPNO DESC) LV
	WHERE ROWNUM < 11;
	
SELECT *
	FROM EMPLOYEE e JOIN EMPLOYEE e2 
		ON e.MGR = e2.EMP;