-- 241 page
-- case
-- if문
-- case when then else end
-- searched, simple

-- CASE 컬럼명 WHEN 비교값 THEN 같을때 ELSE 다를때 END : SIMPLE (SWITCH)
-- CASE WHEN (조건절, 컬럼>값) THEN 조건true ELSE 조건false END : SEARCHED (IF)
 
-- My, BOSTIN 프롯세스은 동부 DALLAS, CHICAGO
SELECT LOC,
		CASE LOC
			WHEN 'NEW YORK' THEN 'EAST'
			WHEN 'DALLS' THEN  'CENTER'
			WHEN 'CHICAGO THEN' THEN 'EAST'
			WHEN 'BOSTON' THEN 'EAST'
			ELSE 'WEST'
		END AS GUBUN
	FROM DEPT d ;
	
-- NVL(컬럼, 값) -> 컬럼의 타입과 값의 타입이 같아야 함
-- THEN 값의 타입과 ELSE 타입이 같아야 함
--SELECT LOC,
--		CASE LOC
--			WHEN 'NEW YORK' THEN 'EAST'
--			ELSE 1
--		END AS GUBUN
--	FROM DEPT d ; 타입 맞춰

-- 익명적 형변환X
--SELECT LOC,
--		CASE LOC
--			WHEN 'NEW YORK' THEN 1
--			ELSE 'WEST'
--		END AS GUBUN
--	FROM DEPT d ; 타입 맞춰

-- ELSE가 없다면 NULL 반환
-- 익명적 형변환X
SELECT LOC,
		CASE LOC
			WHEN 'NEW YORK' THEN 'EAST'
		END AS GUBUN
	FROM DEPT d ;
SELECT LOC,
		NVL(CASE LOC
			WHEN 'NEW YORK' THEN 'EAST'
		END,'ETC')
	FROM DEPT d ;

-- 사원정보 중 급여(SAL)가 3000이상 -> HIGH, 1000이상 -> MID, 500 이하라면 'LOW'
SELECT SAL,
		CASE
			WHEN (SAL>=3000) THEN 'HIGH'
			WHEN (SAL>=1000) THEN 'MID'
			ELSE 'LOW'
		END AS RAKING
	FROM EMP e ;

SELECT DEPTNO,
	CASE 
		WHEN DEPTNO=10 THEN DNAME
		WHEN DEPTNO=20 THEN DNAME 
		WHEN DEPTNO=30 THEN DNAME 
	END
	FROM DEPT d ;
	
-- 사원의 정보중에서 급여가 2000이상이라면 보너스는 1000
--					1000 이상이라면 보너스 500
--					1000 미만이면 보너스 0

SELECT ENAME , SAL,
	CASE  	
		WHEN SAL >= 2000 THEN NVL(COMM,0)+1000
		WHEN SAL >= 1000 THEN NVL(COMM,0)+500
		ELSE NVL(COMM,0)
	END BONUS
	FROM EMP e  ;
	

SELECT ENAME, SAL, 
	CASE 
		WHEN SAL>=2000 THEN 'HIGH'
		ELSE 
			CASE
				WHEN SAL >= 1000 THEN 'MID'
				ELSE 'LOW'
			END
		
	END
	FROM EMP e ;
	

SELECT ENAME , SAL,
	CASE  	
		WHEN SAL >= 2000 THEN NVL(COMM,0)+1000
		ELSE 
			CASE
				WHEN SAL >= 1000 THEN NVL(COMM,0)+500
				ELSE NVL(COMM,0)
			END
	END BONUS
	FROM EMP e  ;
	
SELECT ENAME, SAL,
	CASE 
		WHEN SAL>=2000 THEN NVL(COMM,0)+1000
		ELSE
			CASE
				WHEN SAL>=1000 THEN NVL(COMM,0)+500
				ELSE NVL(0,0)
			END
	END PLUSBONUS
	FROM EMP e ;
	

SELECT DEPTNO, DECODE(DEPTNO,10,'어카운트',20,'세일즈','기타')
	FROM DEPT;
	
-- NULL 미지의 값, 연산의 결과는 NULL, 비교연산의 결과는FALSE
-- 공집합과는 다른 값
SELECT *
	FROM EMP e 
	WHERE EMPNO = '11'; -- 공집합
	
SELECT *
	FROM EMP e 
	WHERE COMM IS NULL; -- NULL
	
SELECT COUNT(COMM) , COUNT(*)
	FROM EMP e
	WHERE COMM=1000; -- 하나의 값을 조회 공집합이 나옴

SELECT COUNT(COMM), COUNT(*)
	FROM EMP e 
	WHERE COMM IS NULL; -- 여러개
	
-- NVL NULL로 되어 있는 컬럼의 값을 치환하여 값으로 출력
-- 판단하는 컬럼과 타입이 같아야 함
--SELECT COMM, NVL(COMM, 'A')
--	FROM EMP;
	
-- NULLIF : 두 개의 컬럼값이 같다면 NULL로 나타냄
	-- 두 개의 컬럼의 타입도 같아야 함
SELECT *
	FROM PLAYER p 
	WHERE PLAYER_ID ='77';
	
SELECT NULLIF(PLAYER_ID, JOIN_YYYY),
		NULLIF(PLAYER_ID, NATION)
		FROM PLAYER p 
		WHERE PLAYER_ID ='77';
		
-- COALESCE : NULL이 아닌 값이 나올때 출력
SELECT COALESCE(PLAYER_ID, PLAYER_NAME, TEAM_ID),
		COALESCE(NICKNAME, PLAYER_NAME),
--		COALESCE (NICKNAME, "POSITION", BACK_NO) -- 같은 타입만 가능
		COALESCE (NICKNAME, "POSITION") -- 모두 NULL 이면 NULL
	FROM PLAYER p 
	WHERE PLAYER_ID ='77';
	
-- NULL연산
-- NULL을 가지고 있는 컬럼의 값은 연산의 갯수에 포함X
SELECT TRUNC(AVG(COMM)), TRUNC(AVG(NVL(COMM,0))),
	SUM(COMM)/COUNT(COMM),
	SUM(NVL(COMM,0))/COUNT(*)
	FROM EMP;
	

-- 선수테이블에서 성남 일화천마 소속 선수들 이름 포지션 출력
-- 없으면 없음 출력
-- NVL 사용, CASE문
SELECT PLAYER_NAME , NVL("POSITION", '없음')
	FROM PLAYER p 
	WHERE TEAM_ID = 'K08';

SELECT PLAYER_NAME,
	CASE   
		WHEN "POSITION" IS NULL THEN '없음'
		ELSE "POSITION"
	END
	FROM PLAYER p 
	WHERE TEAM_ID = 'K08';
	
-- 문제 DEPT DNAME이 SALSE라면 NULL로 변환
SELECT *
	FROM DEPT d ;
	
SELECT DNAME,
	CASE DNAME 
		WHEN 'SALES' THEN NULL
		ELSE DNAME
	END	,
	NULLIF(DNAME, 'SALES')
	FROM DEPT d ;
	
-- 비교대상은 다 같은 타입어야 하고
-- 같은 타입의 결과가 나와야 한다.(컬럼과 상관 없다.)

CREATE TABLE PRODUCT(
		PROD_ID VARCHAR2(10) NOT NULL,
		PROD_NM VARCHAR2(100) NOT NULL,
		REG_DT DATE NOT NULL,
		REGR_NO NUMBER(10,0)
		);
		
ALTER TABLE PRODUCT 
	ADD CONSTRAINT PRODUCT_PK01
	PRIMARY KEY(PROD_ID);
	
DROP TABLE PRODUCT;

ALTER TABLE 기관분류 
	MODIFY (분류명 VARCHAR(30) NOT NULL,
			등록일자 DATE NOT NULL);
			
-- NULL이 의미 : 미지의 값, 연산 NULL, 비교 FALSE
		-- 모르는 값, 값의 부재
		
CREATE TABLE EMP22(
	EMP_NO VARCHAR2(10) PRIMARY KEY,
	EMP_NM VARCHAR2(30) NOT NULL,
	DEPT_CODE VARCHAR2(4) DEFAULT '0000' NOT NULL,
	JOIN_DATE DATE NOT NULL,
	REGIST_DATE DATE 
);

CREATE INDEX IDX_EMP22 ON EMP22 (JOIN_DATE);